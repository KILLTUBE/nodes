<script src="https://cdn.jsdelivr.net/npm/vue@2.6.12"></script>
<style>html,body{margin:0;}</style>
<div id="app">
<canvas></canvas>
<div id="menu" style="position:fixed;left:0;top:0;display:none;">
<div v-for="(n, i) in registered_nodes"><button @click="add_node(n)">{{ n.get_label() }}</button></div>
</div>
</div>
<script>
(function()
{
var ctx = null;
var canvas = null;
var dummy=true;
var nodes = [];
var node_candidate = null;
var signal_candidate = null;
var moving = false;
var selected_node = null;
var selected_signal = null;

var mouse_x=0,mouse_y=0;

class signal
{
	constructor(node,type,x,y,rad)
	{
		this.node=node;
		this.type=type;
		this.x=x;
		this.y=y;
		this.radius = rad;
		this.state = "?";
		this.link = null;
	}
	
	set_state(v)
	{
		this.state = v;
		if(this.type == "output")
		{
			if(this.link != null)
			{
				this.link.set_state(v);
			}
		}
	}
	
	in_bounds(x, y)
	{
		let dx = x-(this.x+this.node.x);
		let dy = y-(this.y+this.node.y);
		let dist = Math.sqrt(dx*dx+dy*dy);
		return dist < this.radius*2;
	}
	
	get_state()
	{
		if(this.type=="input")
		{
			if(this.link==null)
				return "?";
			return this.link.get_state();
		}
		return this.state;
	}
	
	get_state_text()
	{
		if(typeof this.get_state() == "number" && !Number.isSafeInteger(this.get_state()))
		{
			return this.get_state().toFixed(2);
		}
		return this.get_state();
	}
	
	move_relative(dx,dy)
	{
		this.x+=dx;
		this.y+=dy;
	}
	
	draw(abs_x, abs_y, selected)
	{
		ctx.save();
		ctx.fillStyle="#fff";
		ctx.beginPath();
		ctx.arc(abs_x + this.x, abs_y + this.y, this.radius, 0, 2 * Math.PI);
		ctx.fill();
		ctx.restore();
		ctx.save();
		ctx.font="14px arial";
		ctx.strokeStyle=this.type=="input"?"green":"red";
		ctx.fillStyle=this.type=="input"?"green":"red";
		ctx.beginPath();
		ctx.arc(abs_x + this.x, abs_y + this.y, this.radius, 0, 2 * Math.PI);
		if(selected)
		ctx.fill();
		else
		ctx.stroke();
		
		ctx.fillText(this.get_state_text(), abs_x + this.x + 10, abs_y + this.y);
		
		
		if(this.link != null)
		{
			ctx.beginPath();
			ctx.moveTo(abs_x + this.x,abs_y + this.y);
			let dx = this.link.x + this.link.node.x;
			let dy = this.link.y + this.link.node.y;
			ctx.bezierCurveTo(
				(abs_x + this.x + dx) / 2, abs_y + this.y,
				(abs_x + this.x + dx) / 2, dy,
				dx,dy
			);
			//ctx.lineTo(this.link.x,this.link.y);
			//ctx.closePath();
			ctx.stroke();
		}
		ctx.restore();
	}
};

class signal_proxy extends signal
{
	constructor(node,type,x,y,rad)
	{
		super(node,type,x,y,rad);
	}
};

class node_t
{
	set_position(x,y)
	{
		this.x=x;
		this.y=y;
	}
	
	get_label()
	{
		return this.text;
		//this.output.state.constructor.name
	}
	
	set_initial_value()
	{
	}

	constructor(text)
	{
		this.x = 0;
		this.y = 0;
		
		this.color = "rgb(255,255,255)";
		ctx.font="24px arial";
		let m = ctx.measureText(text);
		this.width = m.width * 2;
		this.height = (m.actualBoundingBoxAscent + m.actualBoundingBoxDescent) * 3;
		this.text = text;
		
		this.link = null;
		
		this.signals = [];
		
		let rad = this.height / 8;
		this.io_radius = rad;
		this.inputs = [];
		for(let i = 0; i < 2; ++i)
		{
			let inp = new signal(this, "input", 0,(i+1)*rad*3-rad/2,rad);
			this.inputs.push(inp);
			
			this.signals.push(
				inp
			);
		}
		this.outputs=[];
		this.output = new signal(this, "output", this.width,this.height/2-rad/2,rad);
		for(let i = 0; i < 1; ++i)
		{
			this.signals.push(
				//new signal("output", this.x+this.width-rad*2,this.y+(i+1)*rad*3,rad)
				this.output
			);
			this.outputs.push(this.output);
		}
	}
	
	remove_all_inputs()
	{
		for(let i = this.signals.length - 1; i>=0; i--)
		{
			if(this.signals[i].type=="input")
				this.signals.splice(i, 1);
		}
		this.inputs = [];
	}
	
	remove_all_outputs()
	{
		for(let i = this.signals.length - 1; i>=0; i--)
		{
			if(this.signals[i].type=="output")
				this.signals.splice(i, 1);
		}
		this.outputs = [];
		this.output = null;
	}
	
	value_changed()
	{
	}
	
	add_signal(type)
	{
		if(type == "input")
		{
			let sig = new signal(this, "input", 0,(this.inputs.length+1)*this.io_radius*3-this.io_radius/2,this.io_radius);
			this.height+=(this.signals.length)*this.io_radius*3-this.io_radius/2;
			this.inputs.push(sig);
			this.signals.push(
				sig
			);
		} else if(type == "output")
		{
			let sig = new signal(this, "output", this.width,(this.outputs.length+1)*this.io_radius*3-this.io_radius/2,this.io_radius);
			this.signals.push(
				sig
			);
			this.outputs.push(sig);
		}
	}
	
	move_absolute(x,y)
	{
		let dx = x-this.x;
		let dy = y-this.y;

		this.x += dx;
		this.y += dy;
		/*
		for(let inp in this.signals)
		{
			this.signals[inp].move_relative(dx,dy);
		}
		*/
	}
	
	remove()
	{
		for(let itx in this.signals)
		{
			let sig = this.signals[itx];
			if(sig.link != null)
			{
				sig.link.link = null;
				sig.link.node.value_changed();
			}
		}
	}
	
	get_selected_signal(x,y)
	{
		for(let inp in this.signals)
		{
			if(this.signals[inp].in_bounds(x,y))
				return this.signals[inp];
		}
		return null;
	}
	
	draw(selected)
	{
		/*
		ctx.beginPath();
		ctx.rect(this.x, this.y, this.width, this.height);
		ctx.closePath();
		ctx.stroke();
		*/
		
		let rad=10;
		ctx.save();
		
		ctx.save();
			//ctx.fillStyle="#aaa";
			let angle = 90 * (Math.PI / 180);
			let f = 0.9;
			let grd = ctx.createLinearGradient(this.x,this.y+this.height*f,this.x+Math.cos(angle)*this.width,this.y+Math.sin(angle)*this.height);
			grd.addColorStop(0, this.color);
			grd.addColorStop(1, "#aaa");

			// Fill with gradient
			ctx.fillStyle = grd;
			ctx.roundRect(this.x,this.y,this.width,this.height,rad).fill();
			//ctx.fillStyle="#ccc";
			//ctx.roundRect(this.x,this.y,this.width,this.height*f,rad).fill();
		ctx.restore();
		
		if(selected)
			ctx.lineWidth = 4;
		ctx.strokeStyle="#333";
		ctx.roundRect(this.x,this.y,this.width,this.height,rad).stroke();
		ctx.restore();
		ctx.fillText(this.text, this.x + this.width * (0.25), this.y + this.height - this.height * (1/3));
		
		ctx.save();
			ctx.font="12px arial";
			ctx.fillText(this.output.state==null?"null":this.output.state.constructor.name, this.x + this.width * (0.25), this.y + this.height - 5);		
		ctx.restore();
		for(let inp in this.signals)
		{
			let selected = this.signals[inp].in_bounds(mouse_x,mouse_y);
			this.signals[inp].draw(this.x,this.y,selected || selected_signal == this.signals[inp]);
		}
	}
	
	in_bounds(x, y)
	{
		let v = 30;
		let tx = this.x - v;
		let ty = this.y - v;
		let tw = this.width + v * 2;
		let th = this.height + v * 2;
		return x >= tx && x <= tx + tw && y >= ty && y <= ty + th;
	}
};

class node_rand extends node_t
{
	constructor()
	{
		super("random");
		this.output.set_state(Math.random());
		this.remove_all_inputs();
	}
};

class node_0 extends node_t
{
	constructor(x,y)
	{
		super("constant 0");
		this.remove_all_inputs();
	}
	
	set_initial_value()
	{
		this.output.set_state(0);
	}
};

class node_1 extends node_t
{
	constructor()
	{
		super("constant 1");
		this.output.set_state(1);
		this.remove_all_inputs();
	}
	
	set_initial_value()
	{
		this.output.set_state(1);
	}
};

function prompt_proxy()
{
	if(dummy)
		return;
	return prompt();
}

class node_constant extends node_t
{
	constructor()
	{
		super("constant");
		this.remove_all_inputs();
	}
	
	set_initial_value()
	{
		this.output.set_state(parseFloat(prompt_proxy()));
	}
};

class node_vec3 extends node_t
{
	constructor()
	{
		super("vec3");
		this.remove_all_inputs();
	}
	
	set_initial_value()
	{
		this.output.set_state(
			new vec3(parseFloat(prompt_proxy()),parseFloat(prompt_proxy()),parseFloat(prompt_proxy()))
		);
	}
};

class vec3
{
	constructor(x,y,z)
	{
		this.x=x||0;
		this.y=y||0;
		this.z=z||0;
	}
	
	toString()
	{
		return "("+this.x.toFixed(2)+","+this.y.toFixed(2)+","+this.z.toFixed(2)+")";
	}
};

class node_mathop extends node_t
{
	constructor(name, op)
	{
		super(name);
		this.op = op;
	}
	
	eq(a,b)
	{
		return eval(a + "" +  this.op + "" + b);
	}
	
	is_vec3(a)
	{
		return typeof a == "object" && a.constructor.name == "vec3";
	}
	
	value_changed()
	{
		let a = this.inputs[0].get_state();
		let b = this.inputs[1].get_state();
		if(typeof a == "number" && typeof b == "number")
			this.output.set_state(this.eq(a,b));
		else if(typeof a == "object" && typeof b == "object" && a.constructor.name == "vec3" && b.constructor.name == "vec3")
			this.output.set_state(new vec3(this.eq(a.x,b.x),this.eq(a.y,b.y),this.eq(a.z,b.z)));
		else if(this.is_vec3(a) && typeof b == "number")
		{
			this.output.set_state(new vec3(this.eq(a.x,b),this.eq(a.y,b),this.eq(a.z,b)));
		}
		else if(this.is_vec3(b) && typeof a == "number")
		{
			this.output.set_state(new vec3(this.eq(b.x,a),this.eq(b.y,a),this.eq(b.z,a)));
		} else
			this.output.set_state("invalid");
	}
};

class node_mathop_mul extends node_mathop { constructor() { super("multiply", "*"); } };
class node_mathop_sub extends node_mathop { constructor() { super("subtract", "-"); } };
class node_mathop_div extends node_mathop { constructor() { super("divide", "/"); } };
class node_mathop_add extends node_mathop { constructor() { super("add", "+"); } };

class node_normalize extends node_t
{
	constructor()
	{
		super("normalize");
		this.remove_all_inputs();
		this.add_signal("input");
	}
	
	value_changed()
	{
		let a = this.inputs[0].get_state();
		if(typeof a == "object" && a.constructor.name == "vec3")
		{
			let dot = function(a,b)
			{
				return a.x * b.x + a.y * b.y + a.z * b.z;
			};
			let l = Math.sqrt(dot(a,a));
			this.output.set_state(new vec3(a.x/l,a.y/l,a.z/l));
		}
		else
			this.output.set_state("invalid");
	}
};

class node_extract_vec3 extends node_t
{
	constructor()
	{
		super("vec3 to 3-floats");
		this.remove_all_inputs();
		this.remove_all_outputs();
		this.add_signal("input");
		this.add_signal("output");
		this.add_signal("output");
		this.add_signal("output");
		
		this.output = new signal_proxy(this,"output",0,0,0);
	}
	
	value_changed()
	{
		let a = this.inputs[0].get_state();
		if(typeof a == "object" && a.constructor.name == "vec3")
		{
			this.outputs[0].set_state(a.x);
			this.outputs[1].set_state(a.y);
			this.outputs[2].set_state(a.z);
		} else
		{
			this.outputs[0].set_state(a);
			this.outputs[1].set_state(a);
			this.outputs[2].set_state(a);
		}
	}
};

class node_color extends node_t
{
	constructor()
	{
		super("color");
		this.add_signal("input");
	}
	
	value_changed()
	{
		let r = this.inputs[0].get_state() * 255;
		let g = this.inputs[1].get_state() * 255;
		let b = this.inputs[2].get_state() * 255;
		if(!isNaN(r) && !isNaN(g) && !isNaN(b))
		{
			this.color = "rgb("+r+","+g+","+b+")";
		}
		this.output.set_state(new vec3(r,g,b));
	}
};

var app = new Vue({
	el: "#app",
	data: function()
	{
		return {
			registered_nodes: []
		};
	},
	mounted: function()
	{
	},
	methods:
	{
		add_node: function(n)
		{
			this.closeMenu();
			let o = new (n.constructor)();
			o.set_position(mouse_x, mouse_y);
			o.set_initial_value();
			nodes.push(o);
		},
		register_node: function(n)
		{
			this.registered_nodes.push(n);
		},
		closeMenu: function()
		{
			let menu = document.getElementById("menu");
			menu.style.display="none";
		},
		openMenu: function(ev)
		{
			let menu = document.getElementById("menu");
			menu.style.left = ev.clientX;
			menu.style.top = ev.clientY;
			menu.style.display="block";
		}
	}
});

function get_selected_node()
{
	for(let itx in nodes)
	{
		let node = nodes[itx];
		if(node.in_bounds(mouse_x,mouse_y))
			return node;
	}
	return null;
}

function draw()
{
	if(ctx==null)return;
	if(selected_node != null && moving)
	{
		selected_node.move_absolute(mouse_x,mouse_y);
	}
	ctx.clearRect(0,0,canvas.width,canvas.height);
	for(let itx in nodes)
	{
		let node = nodes[itx];
		let selected = node.in_bounds(mouse_x,mouse_y);
		node.draw(node_candidate == node || selected || node == selected_node);
		
		if(node.link != null)
		{
			ctx.beginPath();
			ctx.moveTo(node.x,node.y);
			ctx.lineTo(node.link.x,node.link.y);
			ctx.closePath();
			ctx.stroke();
		}
	}
	window.requestAnimationFrame(draw);
}

function init()
{
	//https://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas
	CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
	  if (w < 2 * r) r = w / 2;
	  if (h < 2 * r) r = h / 2;
	  this.beginPath();
	  this.moveTo(x+r, y);
	  this.arcTo(x+w, y,   x+w, y+h, r);
	  this.arcTo(x+w, y+h, x,   y+h, r);
	  this.arcTo(x,   y+h, x,   y,   r);
	  this.arcTo(x,   y,   x+w, y,   r);
	  this.closePath();
	  return this;
	}
	canvas = document.getElementsByTagName("canvas")[0];
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	ctx = canvas.getContext("2d");
	
	window.onmouseup=(ev)=>
	{
		moving=false;
		selected_node=null;
	};

	window.oncontextmenu=(ev)=>
	{
		app.openMenu(ev);
		return false;
	}

	window.onmousedown=(ev)=>
	{
		if(ev.buttons!=1)
		{
			let node_index = null;
			for(let itx in nodes)
			{
				let node = nodes[itx];
				if(node.in_bounds(ev.clientX,ev.clientY))
				{
					node_index = itx;
					break;
				}
			}
			if(node_index != null)
			{
				nodes[node_index].remove();
				nodes.splice(node_index, 1);
			}
			return false;
		}
		let node = get_selected_node();
		selected_node=node;
		if(node!=null)
		{
			let sig = node.get_selected_signal(mouse_x, mouse_y);
			if(sig == null)
				moving=true;
		}
	};

	window.onmousemove=(ev)=>
	{
		mouse_x = ev.clientX; mouse_y = ev.clientY;
		
		//get current elements under mouse

		node_candidate = get_selected_node();
	};

	window.onkeydown=(ev)=>
	{
	};

	window.onclick=(ev)=>
	{
		let node = get_selected_node();
		if(node!=null)
		{
			let inp = node.get_selected_signal(ev.clientX, ev.clientY);
			if(inp != null)
			{
				if(selected_signal != null && inp != selected_signal && inp.type != selected_signal.type)
				{			
					if(selected_signal.link!=null&&selected_signal.type!="output")
						selected_signal.link.link=null;
					if(inp.link!=null&&inp.link.link!=null)
						inp.link.link=null;
					selected_signal.link = inp;
					inp.link=selected_signal;
					selected_signal=null;
					node.value_changed();
				} else
					selected_signal = inp;
			}
		}
	};
	
	app.register_node(new node_rand());
	app.register_node(new node_color());
	app.register_node(new node_0());
	app.register_node(new node_1());
	app.register_node(new node_mathop_mul());
	app.register_node(new node_mathop_div());
	app.register_node(new node_mathop_add());
	app.register_node(new node_mathop_sub());
	app.register_node(new node_normalize());
	app.register_node(new node_extract_vec3());
	app.register_node(new node_constant());
	app.register_node(new node_vec3());
}

window.requestAnimationFrame(()=>
{
	//ctx = document.getElementsByTagName("canvas")[0].getContext("2d");
	init();
	window.requestAnimationFrame(draw);
	dummy=false;
});
})();
</script>